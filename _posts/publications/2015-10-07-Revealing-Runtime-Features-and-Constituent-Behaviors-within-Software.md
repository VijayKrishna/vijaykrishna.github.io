---
layout: publication
title: ["Revealing Runtime Features and Constituent Behaviors within Software"]
categories: ['publication']
authors: ["Palepu, Vijay Krishna", "Jones, James"]
conference: ["2015 3rd IEEE Working Conference on Software Visualization (VISSOFT)"]
pages: ["pp.1-10"]
dates: ["27-28 September 2015"]
links: [["paper", "publications/vissoft15_palepu_jones.pdf"], ["website", "https://spideruci.github.io/cerebro"]]
nick: ["Cerebro"]
image: ["cerebro.png"]
abstract: ["Software engineers organize source code into a dominant hierarchy of components and modules that may emphasize various characteristics over runtime behavior. In this way, runtime features may involve cross-cutting aspects of code from multiple components, and some of these features may be emergent in nature, rather than designed. Although source-code modularization assists software engineers to organize and find components, identifying such cross-cutting feature sets can be more difficult. This work presents a visualization that includes a static (i.e., compile-time) representation of source code that gives prominence to clusters of cooperating source-code instructions to identify dynamic (i.e., runtime) features and constituent behaviors within executions of the software. In addition, the visualization animates software executions to reveal which feature clusters are executed and in what order. The result has revealed the principal behaviors of software executions, and those behaviors were revealed to be (in some cases) cohesive, modular source-code structures and (in other cases) cross-cutting, emergent behaviors that involve multiple modules. In this paper, we describe our system (Cerebro), envisage the uses to which it can be put, and evaluate its ability to reveal emergent runtime features and internal constituent behaviors of execution. We found that: (1) the visualization revealed emergent and commonly occuring functionalities that cross-cut the structural decomposition of the system; (2) four independent judges generally agreed in their interpretations of the code clusters, especially when informed only by our visualization; and (3) interacting with the external interface of an application while simultaneously observing the internal execution facilitated localization of code that implements the features and functionality evoked externally."]
---